function e(e,t,o,n){return new(o||(o=Promise))(function(s,i){function r(e){try{c(n.next(e))}catch(e){i(e)}}function l(e){try{c(n.throw(e))}catch(e){i(e)}}function c(e){e.done?s(e.value):new o(function(t){t(e.value)}).then(r,l)}c((n=n.apply(e,t||[])).next())})}const t="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",o=t.length-1;var n=e=>{const n=[];for(;e>=1;)n.push(t[e%(o+1)]),e=e/o|0;return n.join("")};const s=(e,t,o)=>e.addEventListener(t,o),i=e=>{let t=!1,o=null;return(...n)=>t?o:(t=!0,o=e(...n))},r=(e,t)=>setTimeout(t,e),l=function(t){const o=this.config;this.open=!0,this.onReadyQueue.forEach(e=>e()),this.onReadyQueue.splice(0);const{id_key:n,data_key:i}=o.server;this.messages.forEach(e=>e.send()),null!==this.reconnect_timeout&&(clearInterval(this.reconnect_timeout),this.reconnect_timeout=null),s(t,"close",()=>e(this,void 0,void 0,function*(){this.log("Closed."),this.open=!1,this.onCloseQueue.forEach(e=>e()),this.onCloseQueue=[];const t=o.reconnect;if("number"!=typeof t||isNaN(t)||this.forcibly_closed)this.ws=null,this.open=null;else{const o=()=>e(this,void 0,void 0,function*(){this.log("Trying to reconnect..."),null!==this.ws&&(this.ws.close(),this.ws=null),null!==(yield this.connect())&&(this.reconnect_timeout=setTimeout(o,1e3*t))});o()}this.forcibly_closed=!1})),s(t,"message",e=>{try{const t=o.decode(e.data);if(t[n]){const e=this.queue[t[n]];if(e){const o=e.sent_time?Date.now()-e.sent_time:null;this.log("Message.",t[i],o),e.ff(t[i]),clearTimeout(e.timeout),delete this.queue[t[n]]}}}catch(t){console.error(t,`Decode error. Got: ${e.data}`)}})},c=function(e){if(!0===this.open)return e(null);const t=this.config,o=t.socket||t.adapter(`ws://${t.url}`,t.protocols);if(this.ws=o,s(o,"error",i(()=>(this.ws=null,this.log("Error status 3."),e(3)))),!o||o.readyState>1)throw new Error("WSP: Error: ready() on closing or closed state!");o.readyState?(l.call(this,o),e(null)):s(o,"open",i(()=>(this.log("Opened."),l.call(this,o),e(null))))},u={data_type:"json",log:()=>null,timer:!1,url:"localhost",timeout:1400,reconnect:2,lazy:!1,socket:null,adapter:(e,t)=>new WebSocket(e,t),encode:(e,t,{server:o})=>JSON.stringify({[o.id_key]:e,[o.data_key]:t}),decode:e=>JSON.parse(e),protocols:[],pipes:[],server:{id_key:"id",data_key:"data"}},h=e=>{const t=Object.assign(u,e),o=t.url;if("/"==o[0])try{t.url=`${location.hostname}:${location.port}${o}`}catch(e){throw new Error("WSP: URL starting with / in non-browser environment!")}return t},a=Math.pow(2,31)-1;export default class{constructor(e={}){this.open=null,this.ws=null,this.forcibly_closed=!1,this.reconnect_timeout=null,this.queue={},this.messages=[],this.onReadyQueue=[],this.onCloseQueue=[],this.config={},this.config=h(e),this.init_flush(),this.open=!1,this.reconnect_timeout=null,this.forcibly_closed=!1,this.config.lazy||this.connect()}init_flush(){this.queue={},this.messages=[]}log(e,t=null,o=null){const n=this.config;e=`WSP: ${e}`,null!==o?n.log(e,o,t):n.timer?n.log(e,null,t):n.log(e,t)}connect(){return e(this,void 0,void 0,function*(){return new Promise(e=>{c.call(this,e)})})}get socket(){return this.ws}ready(){return e(this,void 0,void 0,function*(){return new Promise(e=>{this.open?e():this.onReadyQueue.push(e)})})}on(e,t,o){return s(this.ws,e,e=>{o&&!o(e)||t(e)})}close(){return e(this,void 0,void 0,function*(){return new Promise((e,t)=>{null===this.ws?t("WSP: closing a non-inited socket!"):(this.open=null,this.onCloseQueue.push(()=>{this.init_flush(),this.ws=null,this.forcibly_closed=!0,e()}),this.ws.close())})})}send(t,o={}){return e(this,void 0,void 0,function*(){this.log("Send.",t);const e=this.config,s={},i=e.server.data_key,l=e.lazy&&!this.open,c=n(Math.random()*(a-10)|0);if("object"==typeof o.top){if(o.top[i])throw new Error("Attempting to set data key/token via send() options!");Object.assign(s,o.top)}if(e.pipes.forEach(e=>t=e(t)),console.log({open:this.open,encoded:e.encode(c,t,e)}),!0===this.open)this.ws.send(e.encode(c,t,e));else if(!1===this.open||l)this.messages.push({send:()=>this.ws.send(e.encode(c,t,e))}),l&&this.connect();else if(null===this.open)throw new Error("Attempting to send via closed WebSocket connection!");return new Promise((t,o)=>{this.queue[c]={ff:t,data_type:e.data_type,sent_time:e.timer?Date.now():null,timeout:r(e.timeout,()=>{this.queue[c]&&(o({"Websocket timeout expired: ":e.timeout,"for the message":s}),delete this.queue[c])})}})})}}
