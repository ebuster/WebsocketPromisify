"use strict";function __awaiter(e,t,n,o){return new(n||(n=Promise))(function(i,s){function c(e){try{l(o.next(e))}catch(e){s(e)}}function r(e){try{l(o.throw(e))}catch(e){s(e)}}function l(e){e.done?i(e.value):new n(function(t){t(e.value)}).then(c,r)}l((o=o.apply(e,t||[])).next())})}const abc="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",ln=abc.length-1;var packNumber=e=>{const t=[];for(;e>=1;)t.push(abc[e%(ln+1)]),e=e/ln|0;return t.join("")};const add_event=(e,t,n)=>e.addEventListener(t,n),once=e=>{let t=!1,n=null;return(...o)=>t?n:(t=!0,n=e(...o))},sett=(e,t)=>setTimeout(t,e),init=function(e){const t=this.config;this.open=!0,this.onReadyQueue.forEach(e=>e()),this.onReadyQueue.splice(0);const{id_key:n,data_key:o}=t.server;this.messages.forEach(e=>e.send()),null!==this.reconnect_timeout&&(clearInterval(this.reconnect_timeout),this.reconnect_timeout=null),add_event(e,"close",()=>__awaiter(this,void 0,void 0,function*(){this.log("Closed."),this.open=!1,this.onCloseQueue.forEach(e=>e()),this.onCloseQueue=[];const e=t.reconnect;if("number"!=typeof e||isNaN(e)||this.forcibly_closed)this.ws=null,this.open=null;else{const t=()=>__awaiter(this,void 0,void 0,function*(){this.log("Trying to reconnect..."),null!==this.ws&&(this.ws.close(),this.ws=null),null!==(yield this.connect())&&(this.reconnect_timeout=setTimeout(t,1e3*e))});t()}this.forcibly_closed=!1})),add_event(e,"message",e=>{try{const i=t.decode(e.data);if(i[n]){const e=this.queue[i[n]];if(e){const t=e.sent_time?Date.now()-e.sent_time:null;this.log("Message.",i[o],t),e.ff(i[o]),clearTimeout(e.timeout),delete this.queue[i[n]]}}}catch(t){console.error(t,`Decode error. Got: ${e.data}`)}})},connectLib=function(e){if(!0===this.open)return e(null);const t=this.config,n=t.socket||t.adapter(`ws://${t.url}`,t.protocols);if(this.ws=n,!n||n.readyState>1)return this.ws=null,this.log("Error: ready() on closing or closed state! Status 2."),e(2);add_event(n,"error",once(()=>(this.ws=null,this.log("Error status 3."),e(3)))),n.readyState?(init.call(this,n),e(null)):add_event(n,"open",once(()=>(this.log("Opened."),init.call(this,n),e(null))))},default_config={data_type:"json",log:()=>null,timer:!1,url:"localhost",timeout:1400,reconnect:2,lazy:!1,socket:null,adapter:(e,t)=>new WebSocket(e,t),encode:(e,t,{server:n})=>JSON.stringify({[n.id_key]:e,[n.data_key]:t}),decode:e=>JSON.parse(e),protocols:[],pipes:[],server:{id_key:"id",data_key:"data"}},enrichConfig=e=>{const t=Object.assign(default_config,e),n=t.url;if("/"==n[0])try{t.url=`${location.hostname}:${location.port}${n}`}catch(e){throw new Error("WSP: URL starting with / in non-browser environment!")}return t},MAX_32=Math.pow(2,31)-1;class WebSocketClient{constructor(e={}){this.open=null,this.ws=null,this.forcibly_closed=!1,this.reconnect_timeout=null,this.queue={},this.messages=[],this.onReadyQueue=[],this.onCloseQueue=[],this.config={},this.config=enrichConfig(e),this.init_flush(),this.open=!1,this.reconnect_timeout=null,this.forcibly_closed=!1,this.config.lazy||this.connect()}init_flush(){this.queue={},this.messages=[]}log(e,t=null,n=null){const o=this.config;e=`WSP: ${e}`,null!==n?o.log(e,n,t):o.timer?o.log(e,null,t):o.log(e,t)}connect(){return __awaiter(this,void 0,void 0,function*(){return new Promise(e=>{connectLib.call(this,e)})})}get socket(){return this.ws}ready(){return __awaiter(this,void 0,void 0,function*(){return new Promise(e=>{this.open?e():this.onReadyQueue.push(e)})})}on(e,t,n){return add_event(this.ws,e,e=>{n&&!n(e)||t(e)})}close(){return __awaiter(this,void 0,void 0,function*(){return new Promise((e,t)=>{null===this.ws?t("WSP: closing a non-inited socket!"):(this.open=null,this.onCloseQueue.push(()=>{this.init_flush(),this.ws=null,this.forcibly_closed=!0,e()}),this.ws.close())})})}send(e,t={}){return __awaiter(this,void 0,void 0,function*(){this.log("Send.",e);const n=this.config,o={},i=n.server.data_key,s=n.lazy&&!this.open,c=packNumber(Math.random()*(MAX_32-10)|0);if("object"==typeof t.top){if(t.top[i])throw new Error("Attempting to set data key/token via send() options!");Object.assign(o,t.top)}if(n.pipes.forEach(t=>e=t(e)),console.log({open:this.open,encoded:n.encode(c,e,n)}),!0===this.open)this.ws.send(n.encode(c,e,n));else if(!1===this.open||s)this.messages.push({send:()=>this.ws.send(n.encode(c,e,n))}),s&&this.connect();else if(null===this.open)throw new Error("Attempting to send via closed WebSocket connection!");return new Promise((e,t)=>{this.queue[c]={ff:e,data_type:n.data_type,sent_time:n.timer?Date.now():null,timeout:sett(n.timeout,()=>{this.queue[c]&&(t({"Websocket timeout expired: ":n.timeout,"for the message":o}),delete this.queue[c])})}})})}}module.exports=WebSocketClient;
