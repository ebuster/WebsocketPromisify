"use strict";
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */function t(t,e,s,o){return new(s||(s=Promise))((function(n,i){function l(t){try{c(o.next(t))}catch(t){i(t)}}function r(t){try{c(o.throw(t))}catch(t){i(t)}}function c(t){t.done?n(t.value):new s((function(e){e(t.value)})).then(l,r)}c((o=o.apply(t,e||[])).next())}))}const e="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",s=e.length-1;const o=(t,e,s)=>t.addEventListener(e,s),n=t=>{let e=!1,s=null;return(...o)=>e?s:(e=!0,s=t(...o))},i=function(e){const s=this.config;this.open=!0,this.onReadyQueue.forEach(t=>t()),this.onReadyQueue.splice(0);const{id_key:n,data_key:i}=s.server;this.messages.forEach(t=>t.send()),null!==this.reconnect_timeout&&(clearInterval(this.reconnect_timeout),this.reconnect_timeout=null),o(e,"close",()=>t(this,void 0,void 0,(function*(){this.log("close"),this.open=!1,this.onCloseQueue.forEach(t=>t()),this.onCloseQueue=[];const e=s.reconnect;if("number"!=typeof e||isNaN(e)||this.forcibly_closed)this.ws=null,this.open=null;else{const s=()=>t(this,void 0,void 0,(function*(){this.log("reconnect"),null!==this.ws&&(this.ws.close(),this.ws=null),null!==(yield this.connect())&&(this.reconnect_timeout=setTimeout(s,1e3*e))}));s()}this.forcibly_closed=!1}))),o(e,"message",t=>{try{const e=s.decode(t.data);if(e[n]){const t=this.queue[e[n]];if(t){const s=t.sent_time?Date.now()-t.sent_time:null;this.log("message",e[i],s),t.ff(e[i]),clearTimeout(t.timeout),delete this.queue[e[n]]}}}catch(e){console.error(e,`WSP: Decode error. Got: ${t.data}`)}})},l=function(t){if(!0===this.open)return t(null);const e=this.config,s=e.socket||e.adapter(e.url,e.protocols);if(this.ws=s,!s||s.readyState>1)return this.ws=null,this.log("error","ready() on closing or closed state! status 2."),t(2);o(s,"error",n(()=>(this.ws=null,this.log("error","status 3."),t(3)))),s.readyState?(i.call(this,s),t(null)):o(s,"open",n(()=>(this.log("open"),i.call(this,s),t(null))))},r={data_type:"json",log:()=>null,timer:!1,url:"localhost",timeout:1400,reconnect:2,lazy:!1,socket:null,adapter:(t,e)=>new WebSocket(t,e),encode:(t,e,{server:s})=>JSON.stringify({[s.id_key]:t,[s.data_key]:e}),decode:t=>JSON.parse(t),protocols:[],pipes:[],server:{id_key:"id",data_key:"data"}},c=Math.pow(2,31)-1;module.exports=class{constructor(t={}){this.open=null,this.ws=null,this.forcibly_closed=!1,this.reconnect_timeout=null,this.queue={},this.messages=[],this.onReadyQueue=[],this.onCloseQueue=[],this.config={},this.config=(t=>{const e=Object.assign({},r,t),s=e.url;if("/"==s[0])try{const t=location.protocol.includes("s:")?"wss":"ws";e.url=`${t}://${location.hostname}:${location.port}${s}`}catch(t){throw new Error("WSP: URL starting with / in non-browser environment!")}return e})(t),this.init_flush(),this.open=!1,this.reconnect_timeout=null,this.forcibly_closed=!1,this.config.lazy||this.connect()}init_flush(){this.queue={},this.messages=[]}log(t,e=null,s=null){const o=this.config;null!==s?o.log(t,s,e):o.timer?o.log(t,null,e):o.log(t,e)}connect(){return t(this,void 0,void 0,(function*(){return new Promise(t=>{l.call(this,t)})}))}get socket(){return this.ws}ready(){return t(this,void 0,void 0,(function*(){return new Promise(t=>{this.open?t():this.onReadyQueue.push(t)})}))}on(t,e,s){return o(this.ws,t,t=>{s&&!s(t)||e(t)})}close(){return t(this,void 0,void 0,(function*(){return new Promise((t,e)=>{null===this.ws?e("WSP: closing a non-inited socket!"):(this.open=null,this.onCloseQueue.push(()=>{this.init_flush(),this.ws=null,this.forcibly_closed=!0,t(null)}),this.ws.close())})}))}send(o,n={}){return t(this,void 0,void 0,(function*(){this.log("send",o);const t=this.config,i={},l=t.server.data_key,r=t.lazy&&!this.open,u=(t=>{const o=[];for(;t>=1;)o.push(e[t%(s+1)]),t=t/s|0;return o.join("")})(Math.random()*(c-10)|0);if("object"==typeof n.top){if(n.top[l])throw new Error("Attempting to set data key/token via send() options!");Object.assign(i,n.top)}if(t.pipes.forEach(t=>o=t(o)),!0===this.open)this.ws.send(t.encode(u,o,t));else if(!1===this.open||r)this.messages.push({send:()=>this.ws.send(t.encode(u,o,t))}),r&&this.connect();else if(null===this.open)throw new Error("Attempting to send via closed WebSocket connection!");return new Promise((e,s)=>{var o,n;this.queue[u]={ff:e,data_type:t.data_type,sent_time:t.timer?Date.now():null,timeout:(o=t.timeout,n=()=>{this.queue[u]&&(s({"Websocket timeout expired: ":t.timeout,"for the message":i}),delete this.queue[u])},setTimeout(n,o))}})}))}};
